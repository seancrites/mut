#!/usr/bin/expect -f
#
# Script: mut_up.exp
# Purpose: Automates MikroTik RouterOS upgrades via SSH, with optional test mode and version specification
# Author: Sean Crites
# Version: 1.0.20
# Created: 2025-05-18
# Last Updated: 2025-06-04
#
# Copyright (c) 2025 Sean Crites <sean.crites@gmail.com>
# This script is licensed under the BSD 3-Clause License.
# See the LICENSE file in the project root for the full license text.
#
# Requirements:
#    - Expect (version 5.45 or later)
#    - SSH client (OpenSSH recommended, version 7.0 or later)
#    - scp for file transfers
#    - sshpass (version 1.06 or later) for non-interactive SCP
#    - sh for executing SCP commands
#    - RouterOS .npk files in ROS_IMAGE_DIR
#    - Credentials file with username and password
#    - SSH access to MikroTik device (port 22, admin privileges)
#    - Write permissions for BACKUP_DIR and LOGS_DIR
#
# Usage:
#   mut_up.exp [-t|--test] [-d|--debug] [-l] [-r version] <host> <backup_dir> <ros_image_dir> <cred_file>
# Options:
#    -t, --test    Test mode: Simulates file upload, auto-update settings, and reboots
#    -d, --debug   Debug mode: Enables verbose Expect debugging, displays debug details on console, and creates a debug log in LOGS_DIR (independent of -l)
#    -l            Log mode: Creates an upgrade log in LOGS_DIR and displays messages to user
#    -r version    Specify RouterOS version (e.g., 7.17.2 or 7.17) for upgrade or downgrade
#
# Notes:
#    - The -d option generates a debug log (logs/mut_upgrade_debug_*.log) containing all CLI interactions, Expect diagnostics, and upgrade log messages, independent of -l.
#    - Debug mode (-d) outputs debug details to both the console (stderr for diagnostics, stdout for CLI) and the debug log, with passwords suppressed for security.
#    - Without -d, console output is limited to upgrade messages and commands (stderr), suppressing MikroTik banner and CLI interactions.
#    - Exit codes:
#        - 0: Success
#        - 1: Invalid credentials (Permission denied, Login failed)
#        - 2: SSH timeout
#        - 3: Connection refused
#        - 4: General SSH failure
#        - 5: Other errors (e.g., missing credentials, file issues)
#

# Initialize variables
set reboot_initiated 0
set max_attempts 60
set early_exit 0
set mtik_cli "+tce200w"

log_user 0

# Display help message
if {[lindex $argv 0] == "--help"} {
   puts "Usage: [info script] \[-t|--test\] \[-d|--debug\] \[-l\] \[-r version\] <host> <backup_dir> <ros_image_dir> <cred_file>"
   puts "Options:"
   puts "  -t, --test    Test mode: Simulates file upload, auto-update settings, and reboots"
   puts "  -d, --debug   Debug mode: Enables verbose Expect debugging, displays debug details on console, and creates a debug log in LOGS_DIR (independent of -l)"
   puts "  -l            Log mode: Creates an upgrade log in LOGS_DIR and displays messages to user"
   puts "  -r version    Specify RouterOS version (e.g., 7.17.2 or 7.17) for upgrade or downgrade"
   exit 0
}

# Log function for normal logging
proc log_msg {msg} {
   global debug_mode logging log_file_handle log_file
   set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
   puts stderr "\[$timestamp\]: $msg"
   if {$logging && [info exists log_file_handle]} {
      if {[catch {puts $log_file_handle "\[$timestamp\]: $msg"} err]} {
         puts stderr "\[$timestamp\]: ERROR: Failed to write to log file $log_file: $err"
         debug_log "Failed to write to log file $log_file: $err, message: $msg"
      } else {
         flush $log_file_handle
      }
   }
   if {$debug_mode} {
      debug_log "\[$timestamp\]: $msg"
   }
}

# Log function for debug file only
proc debug_log {msg} {
   global debug_mode debug_file_handle
   if {$debug_mode && [info exists debug_file_handle]} {
      puts $debug_file_handle "\[[clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]\]: $msg"
      flush $debug_file_handle
   }
}

# Log function for commands sent to MikroTik
proc log_cmd {cmd} {
   global debug_mode logging log_file_handle
   set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
   puts stderr "\[$timestamp\]: CMD> $cmd"
   if {$logging && [info exists log_file_handle]} {
      if {[catch {puts $log_file_handle "\[$timestamp\]: CMD> $cmd"} err]} {
         puts stderr "\[$timestamp\]: ERROR: Failed to write to log file: $err"
         debug_log "Failed to write to log file: $err, command: $cmd"
      } else {
         flush $log_file_handle
      }
   }
   if {$debug_mode} {
      debug_log "\[$timestamp\]: CMD> $cmd"
   }
}

# Handle failure with modular error messaging
proc fail_with_error {msg code} {
   global debug_mode logging log_file_handle debug_file_handle
   # Log error message and debug info before closing handles
   log_msg "ERROR: $msg (code $code)"
   if {$debug_mode && [info exists debug_file_handle]} {
      debug_log "Exiting with error: $msg (code $code)"
   }
   puts stderr "$msg"
   # Close file handles after all logging is complete
   if {$logging && [info exists log_file_handle]} {
      catch {close $log_file_handle}
   }
   if {$debug_mode && [info exists debug_file_handle]} {
      catch {close $debug_file_handle}
      log_file
   }
   log_user 0
   exit $code
}

# Wrapper for sending commands to MikroTik
proc send_cmd {cmd} {
   log_cmd $cmd
   send "$cmd\r"
}

# Parse key-value pairs from system output
proc parse_system_output {output} {
   set result {}
   set pairs [split $output ";"]
   foreach pair $pairs {
      if {[regexp {([^=]+)=([^;]*)} $pair {} key value]} {
         set key [string trim $key]
         set value [string trim $value]
         dict set result $key $value
      }
   }
   return $result
}

# Parse command output from expect buffer
proc parse_command_output {buffer cmd regex_pattern debug_mode} {
   debug_log "Raw buffer: '$buffer'"
   set normalized_buffer [regsub -all {\r+\n*|\n+} $buffer "\n"]
   debug_log "Normalized buffer: '$normalized_buffer'"
   set lines [split $normalized_buffer "\n"]
   set output ""
   set capture 0
   foreach line $lines {
      set line [string trim $line]
      debug_log "Processing line: '$line'"
      if {$line == $cmd} {
         set capture 1
         debug_log "Found command, capturing next non-prompt line"
         continue
      }
      if {$capture && $line != "" && ![regexp {\[.*\] >} $line]} {
         set output $line
         debug_log "Captured output: '$output'"
         break
      }
   }
   if {$output == ""} {
      debug_log "Fallback: searching buffer for key-value line"
      if {[regexp $regex_pattern $normalized_buffer match]} {
         set output [string trim $match]
         debug_log "Captured output (fallback): '$output'"
      }
   }
   if {$output != ""} {
      debug_log "Parsing output: '$output'"
      return [parse_system_output $output]
   } else {
      debug_log "No output captured"
      return {}
   }
}

# Parse package output to identify addon packages
proc parse_packages {buffer cmd debug_mode} {
   debug_log "Parsing packages from buffer: '$buffer'"
   set normalized_buffer [regsub -all {\r+\n*|\n+} $buffer "\n"]
   debug_log "Normalized package buffer: '$normalized_buffer'"
   set packages {}
   set entries [split $normalized_buffer "\n"]
   set capture 0
   foreach entry $entries {
      set entry [string trim $entry]
      debug_log "Processing package entry: '$entry'"
      if {$entry == $cmd} {
         set capture 1
         debug_log "Found package command, capturing output"
         continue
      }
      if {$capture && $entry != "" && ![regexp {\[.*\] >} $entry]} {
         # Use regex to capture complete package records starting with .id=*
         set package_records {}
         set start 0
         while {[regexp -start $start -indices {\.id=\*[0-9]+;} $entry match]} {
            set match_start [lindex $match 0]
            set match_end [lindex $match 1]
            # Find the next .id=* or end of string
            set next_start [expr {$match_end + 1}]
            if {[regexp -start $next_start -indices {\.id=\*[0-9]+;} $entry next_match]} {
               set record_end [lindex $next_match 0]
            } else {
               set record_end [string length $entry]
            }
            # Extract the record
            set record [string range $entry $match_start $record_end]
            if {$record != ""} {
               lappend package_records $record
            }
            set start $record_end
         }
         debug_log "Found [llength $package_records] package records: [join $package_records ", "]"
         foreach record $package_records {
            debug_log "Parsing package record: '$record'"
            if {$record != ""} {
               set package_info [parse_system_output $record]
               debug_log "Parsed package info: '$package_info'"
               if {[dict exists $package_info name] && [dict get $package_info name] != ""} {
                  set package_name [dict get $package_info name]
                  if {$package_name != "routeros"} {
                     # Deduplicate package names
                     if {$package_name ni $packages} {
                        lappend packages $package_name
                        debug_log "Found addon package: $package_name"
                     } else {
                        debug_log "Skipping duplicate addon package: $package_name"
                     }
                  } else {
                     debug_log "Skipping routeros package"
                  }
               } else {
                  debug_log "Skipping invalid record: no name key or empty name"
               }
            }
         }
      }
   }
   if {[llength $packages] == 0} {
      debug_log "No addon packages found"
   } else {
      debug_log "Addon packages: [join $packages ", "]"
   }
   return $packages
}

# Compare two version strings (e.g., 7.17.2 vs 7.17.1)
# Returns: 1 if v1 > v2, 0 if v1 == v2, -1 if v1 < v2
proc compare_versions {v1 v2} {
   set v1_parts [split $v1 "."]
   set v2_parts [split $v2 "."]
   set len [expr { [llength $v1_parts] > [llength $v2_parts] ? [llength $v1_parts] : [llength $v2_parts] }]
   for {set i 0} {$i < $len} {incr i} {
      set n1 [expr { $i < [llength $v1_parts] ? [lindex $v1_parts $i] : 0 }]
      set n2 [expr { $i < [llength $v2_parts] ? [lindex $v2_parts $i] : 0 }]
      if {$n1 > $n2} {
         return 1
      } elseif {$n1 < $n2} {
         return -1
      }
   }
   return 0
}

# Select RouterOS version and return .npk file paths for main and addon packages
proc select_ros_version {version arch ros_image_dir addon_packages} {
   global debug_mode
   set major_minor ""
   set npk_files {}
   set selected_version ""
   # Validate version format (N.NN or N.NN.N)
   if {[regexp {^[0-9]\.[0-9][0-9]$} $version]} {
      set major_minor $version
   } elseif {[regexp {^[0-9]\.[0-9][0-9]\.[0-9]$} $version]} {
      set major_minor [regsub {\.[0-9]$} $version ""]
   } else {
      fail_with_error "Invalid version format '$version'. Use N.NN or N.NN.N" 5
   }
   # Set version_dir to ros_image_dir/vN.NN
   set version_dir "$ros_image_dir/v$major_minor"
   if {![file exists $version_dir]} {
      fail_with_error "Directory $version_dir does not exist" 5
   }
   # Handle main routeros package
   if {[regexp {^[0-9]\.[0-9][0-9]$} $version]} {
      set pattern "$version_dir/routeros-$version*[0-9]-$arch.npk"
      debug_log "Searching for highest routeros version with pattern: $pattern"
      set files [glob -nocomplain $pattern]
      if {$files == ""} {
         fail_with_error "No RouterOS version found in $version_dir for architecture $arch" 5
      }
      set routeros_file ""
      set latest_version "0.0.0"
      foreach file $files {
         if {[regexp "routeros-(\[0-9]\.\[0-9][0-9]\.\[0-9])-.*\.npk$" $file {} ver]} {
            if {[compare_versions $ver $latest_version] > 0} {
               set latest_version $ver
               set routeros_file $file
            }
         }
      }
      if {$routeros_file == ""} {
         fail_with_error "No valid RouterOS version found in $version_dir for architecture $arch" 5
      }
      set selected_version $latest_version
      lappend npk_files $routeros_file
      log_msg "Selected highest routeros version: $selected_version for $arch ($routeros_file)"
   } else {
      set routeros_file "$version_dir/routeros-$version-$arch.npk"
      debug_log "Checking for exact routeros version file: $routeros_file"
      if {![file exists $routeros_file]} {
         fail_with_error "Version $version not available for architecture $arch in $version_dir" 5
      }
      set selected_version $version
      lappend npk_files $routeros_file
      log_msg "Selected exact routeros version: $selected_version for $arch ($routeros_file)"
   }
   # Handle addon packages
   set missing_packages {}
   foreach pkg $addon_packages {
      set pkg_file "$version_dir/$pkg-$selected_version-$arch.npk"
      debug_log "Checking for addon package file: $pkg_file"
      if {[file exists $pkg_file]} {
         lappend npk_files $pkg_file
         log_msg "Selected addon package: $pkg-$selected_version for $arch ($pkg_file)"
      } else {
         lappend missing_packages $pkg
         debug_log "Addon package $pkg-$selected_version-$arch.npk not found"
      }
   }
   if {[llength $missing_packages] > 0} {
      fail_with_error "Update unsuccessful due to missing v$selected_version for $arch, packages: [join $missing_packages ", "]" 5
   }
   return [list $npk_files $selected_version]
}

# Perform pre-flight checks
proc preflight_checks {backup_dir ros_image_dir logging logs_dir} {
   global debug_mode
   if {![file exists $ros_image_dir]} {
      fail_with_error "ROS_IMAGE_DIR $ros_image_dir does not exist" 5
   }
   if {![file exists $backup_dir]} {
      fail_with_error "BACKUP_DIR $backup_dir does not exist" 5
   }
   if {![file writable $backup_dir]} {
      fail_with_error "BACKUP_DIR $backup_dir is not writable" 5
   }
   if {$logging} {
      if {![file exists $logs_dir]} {
         if {[catch {file mkdir $logs_dir} err]} {
            fail_with_error "Cannot create LOGS_DIR $logs_dir: $err" 5
         }
      }
      if {![file writable $logs_dir]} {
         fail_with_error "LOGS_DIR $logs_dir is not writable" 5
      }
   }
   foreach cmd {ssh scp sshpass sh} {
      if {[catch {exec which $cmd} result]} {
         fail_with_error "Required command '$cmd' not found in PATH" 5
      }
      if {$debug_mode} {
         log_msg "Pre-flight: Found $cmd at [exec which $cmd]"
      }
   }
   log_msg "Pre-flight checks passed"
}

# Check firmware and reboot if needed
proc check_and_reboot_firmware {host username password prompt max_attempts test_mode debug_mode logging} {
   global escaped_host mtik_cli
   log_msg "Checking firmware versions"
   send_cmd ":put \[/system/routerboard/print as-value\]"
   after 5000
   expect {
      -re $prompt {
         set parsed [parse_command_output $expect_out(buffer) ":put \[/system/routerboard/print as-value\]" {current-firmware=[^\r\n;]+;.*upgrade-firmware=[^\r\n;]+} $debug_mode]
         if {[dict size $parsed] > 0} {
            if {[dict exists $parsed current-firmware] && [dict exists $parsed upgrade-firmware]} {
               set current_firmware [dict get $parsed current-firmware]
               set upgrade_firmware [dict get $parsed upgrade-firmware]
               debug_log "Current firmware: '$current_firmware', Upgrade firmware: '$upgrade_firmware'"
               if {$current_firmware != $upgrade_firmware} {
                  log_msg "Firmware mismatch: current-firmware=$current_firmware, upgrade-firmware=$upgrade_firmware. Rebooting to apply."
                  if {$test_mode} {
                     log_msg "Test mode: Skipping firmware reboot"
                     return 0
                  }
                  send_cmd "/system/reboot"
                  expect {
                     -re {Reboot, yes\? \[y/N\]:[ \r\n]*} {
                        send_cmd "y"
                        expect {
                           eof {
                              log_msg "Firmware reboot command sent"
                           }
                           timeout {
                              fail_with_error "Timeout during firmware reboot command" 5
                           }
                        }
                     }
                     timeout {
                        fail_with_error "Timeout waiting for firmware reboot prompt" 5
                     }
                  }
                  log_msg "Waiting for $host to reboot"
                  set attempt 0
                  while {$attempt < $max_attempts} {
                     after 10000
                     spawn ssh -o StrictHostKeyChecking=no $username$mtik_cli@$host
                     expect {
                        "password:" {
                           log_user 0
                           send "$password\r"
                           expect {
                              -re $prompt {
                                 log_msg "Reconnected to $host after firmware reboot"
                                 break
                              }
                              timeout {
                                 log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
                              }
                           }
                        }
                        timeout {
                           log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
                        }
                     }
                     incr attempt
                     log_msg "Attempt $attempt of $max_attempts: Still waiting for $host"
                  }
                  if {$attempt >= $max_attempts} {
                     fail_with_error "Device $host did not come back online after firmware reboot" 5
                  }
                  # Recheck firmware after reboot
                  log_msg "Rechecking firmware versions"
                  send_cmd ":put \[/system/routerboard/print as-value\]"
                  after 5000
                  expect {
                     -re $prompt {
                        set recheck_parsed [parse_command_output $expect_out(buffer) ":put \[/system/routerboard/print as-value\]" {current-firmware=[^\r\n;]+;.*upgrade-firmware=[^\r\n;]+} $debug_mode]
                        if {[dict size $recheck_parsed] > 0} {
                           if {[dict exists $recheck_parsed current-firmware] && [dict exists $recheck_parsed upgrade-firmware]} {
                              set new_current_firmware [dict get $recheck_parsed current-firmware]
                              set new_upgrade_firmware [dict get $recheck_parsed upgrade-firmware]
                              debug_log "Recheck: Current firmware: '$new_current_firmware', Upgrade firmware: '$new_upgrade_firmware'"
                              if {$new_current_firmware != $new_upgrade_firmware} {
                                 fail_with_error "Firmware mismatch persists: current-firmware=$new_current_firmware, upgrade-firmware=$new_upgrade_firmware" 5
                              } else {
                                 log_msg "Firmware verified: current-firmware=$new_current_firmware, upgrade-firmware=$new_upgrade_firmware"
                                 return 1
                              }
                           } else {
                              fail_with_error "No current-firmware or upgrade-firmware in recheck output" 5
                           }
                        } else {
                           fail_with_error "Failed to capture routerboard output during recheck" 5
                        }
                     }
                     eof {
                        fail_with_error "SSH session lost during firmware recheck" 4
                     }
                     timeout {
                        fail_with_error "Timeout waiting for routerboard response during recheck" 2
                     }
                  }
               } else {
                  log_msg "Firmware verified: current-firmware=$current_firmware, upgrade-firmware=$upgrade_firmware"
                  return 1
               }
            } else {
               log_msg "No routerboard firmware information available, skipping firmware check"
               return 1
            }
         } else {
            log_msg "No routerboard firmware output received, skipping firmware check"
            return 1
         }
      }
      eof {
         fail_with_error "SSH session lost during firmware check" 4
      }
      timeout {
         fail_with_error "Timeout waiting for routerboard response" 2
      }
   }
}

# Parse arguments
set test_mode 0
set debug_mode 0
set logging 0
set target_version ""
set argv_new {}
set i 0
set argc [llength $argv]

while {$i < $argc} {
   set arg [lindex $argv $i]
   if {$arg == "--"} {
      incr i
      continue
   }
   if {$arg == "-t" || $arg == "--test"} {
      set test_mode 1
      incr i
      continue
   }
   if {$arg == "-d" || $arg == "--debug"} {
      set debug_mode 1
      incr i
      continue
   }
   if {$arg == "-l"} {
      set logging 1
      incr i
      continue
   }
   if {$arg == "-r"} {
      incr i
      if {$i >= $argc} {
         fail_with_error "Missing version argument after -r" 5
      }
      set target_version [lindex $argv $i]
      incr i
      continue
   }
   lappend argv_new $arg
   incr i
}
set argv $argv_new

if {[llength $argv] != 4} {
   fail_with_error "Usage: [info script] \[-t|--test\] \[-d|--debug\] \[-l\] \[-r version\] <host> <backup_dir> <ros_image_dir> <cred_file>" 5
}

set host_cli [lindex $argv 0]
set backup_dir [lindex $argv 1]
set ros_image_dir [lindex $argv 2]
set cred_file [lindex $argv 3]

set script_dir [file dirname [info script]]
set logs_dir "$script_dir/logs"

# Source options file
set options_file "$script_dir/mut_opt.conf"
if {[file exists $options_file] && [file readable $options_file]} {
   set fp [open $options_file r]
   while {[gets $fp line] >= 0} {
      if {[regexp {^\s*(\w+)\s*=\s*(.+?)\s*$} $line {} key value]} {
         set value [string trim $value]
         if {$value != ""} {
            if {[regexp {\$PWD} $value]} {
               if {[info exists env(PWD)]} {
                  set value [string map [list "\$PWD" $env(PWD)] $value]
               } else {
                  log_msg "WARNING: Environment variable PWD not set, using current directory"
                  set value [string map [list "\$PWD" [pwd]] $value]
               }
            }
            if {$key == "ROS_IMAGE_DIR"} {
               set ros_image_dir $value
            } elseif {$key == "BACKUP_DIR"} {
               set backup_dir $value
            } elseif {$key == "LOGS_DIR"} {
               set logs_dir $value
            } elseif {$key == "SSH_TIMEOUT"} {
               set timeout $value
            }
            if {$debug_mode} {
               log_msg "Set $key=$value from $options_file"
            }
         }
      }
   }
   close $fp
}

if {[regexp {\$PWD} $logs_dir]} {
   if {[info exists env(PWD)]} {
      set logs_dir [string map [list "\$PWD" $env(PWD)] $logs_dir]
   } else {
      log_msg "WARNING: Environment variable PWD not set, using current directory"
      set logs_dir [string map [list "\$PWD" [pwd]] $logs_dir]
   }
}

# Set up logging
if {$logging} {
   set log_file "$logs_dir/mut_upgrade_[clock format [clock seconds] -format %Y%m%d_%H%M%S].log"
   if {[catch {open $log_file w} log_file_handle]} {
      fail_with_error "Failed to open log file $log_file: $log_file_handle" 5
   }
   debug_log "Opened log file $log_file with handle $log_file_handle"
   if {[catch {chan configure $log_file_handle -buffering line} err]} {
      log_msg "WARNING: Failed to configure log file channel $log_file: $err"
      debug_log "Failed to configure log file channel: $err"
   }
   set log_start_time [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
   if {[catch {puts $log_file_handle "Log file opened at $log_start_time"} err]} {
      log_msg "WARNING: Failed to write to log file $log_file: $err"
      debug_log "Failed to write to log file: $err"
   } else {
      flush $log_file_handle
      log_msg "Logging enabled: Output will be saved to $log_file"
   }
}

# Enable debug mode
if {$debug_mode} {
   exp_internal 1
   set debug_file "$logs_dir/mut_upgrade_debug_[clock format [clock seconds] -format %Y%m%d_%H%M%S].log"
   if {[catch {open $debug_file w} debug_file_handle]} {
      fail_with_error "Failed to open debug log file $debug_file: $debug_file_handle" 5
   }
   set debug_start_time [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
   if {[catch {puts $debug_file_handle "Debug log opened at $debug_start_time"} err]} {
      log_msg "WARNING: Failed to write to debug log file $debug_file: $err"
   } else {
      flush $debug_file_handle
      log_msg "Debug mode enabled, logging to $debug_file"
   }
   log_file -a $debug_file
   log_user 1
}

# Run pre-flight checks
preflight_checks $backup_dir $ros_image_dir $logging $logs_dir

# Parse host to extract short hostname
if {[regexp {\.(com|org|net|int|edu|gov|mil|biz|info|co\.uk|org\.uk|gov\.uk)$} $host_cli]} {
   set host [regsub {\.[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+$|\.[a-zA-Z0-9-]+\.co\.uk$|\.[a-zA-Z0-9-]+\.org\.uk$|\.[a-zA-Z0-9-]+\.gov\.uk$} $host_cli ""]
   debug_log "Original host: '$host_cli', Short hostname: '$host' (domain suffix stripped)"
} else {
   set host $host_cli
   debug_log "Original host: '$host_cli', Short hostname: '$host' (no domain suffix detected)"
}

# Read credentials
if {![file readable $cred_file]} {
   fail_with_error "Credential file $cred_file is not readable" 5
}
set fp [open $cred_file r]
set creds [read $fp]
close $fp

set username ""
set password ""
foreach line [split $creds "\n"] {
   if {[regexp {^username=(.*)$} $line {} value]} {
      set username $value
   } elseif {[regexp {^password=(.*)$} $line {} value]} {
      #pragma: password
      set password $value
   }
}

if {$username == "" || $password == ""} {
   fail_with_error "Missing username or password in $cred_file" 5
}

# Parsing and setting host
set escaped_host [regsub -all {[][\\+*.?{}()^$|]} $host {\\&}]
set escaped_username [regsub -all {[][\\+*.?{}()^$|]} $username {\\&}]

set prompt "\\\[.*@${escaped_host}\\\] > \$"

# Connect to MikroTik
log_msg "Connecting to $host_cli as $username"
spawn ssh -o StrictHostKeyChecking=no $username$mtik_cli@$host
expect {
   "password:" {
      log_user 0
      send "$password\r"
      expect {
         -timeout 10
         -re {\r\n(?:\r\n)*\s*MMM.*\r\n} {
            exp_continue
         }
         -re {\r\n\s*MikroTik.*\r\n} {
            exp_continue
         }
         -re {\r\n\s*Press F1.*\r\n} {
            exp_continue
         }
         -re $prompt {
            log_msg "Logged in to $host"
         }
         timeout {
            # Fallback to FQDN prompt
            set escaped_fqdn [regsub -all {[][\\+*.?{}()^$|]} $host_cli {\\&}]
            set fqdn_prompt "\\\[.*@${escaped_fqdn}\\\] > \$"
            debug_log "Retrying with FQDN prompt: $fqdn_prompt"
            expect {
               -re $fqdn_prompt {
                  log_msg "Logged in to $host_cli using FQDN prompt"
                  set prompt $fqdn_prompt
               }
               "Permission denied" {
                  fail_with_error "Invalid credentials" 1
               }
               "Login failed" {
                  fail_with_error "Invalid credentials" 1
               }
               timeout {
                  fail_with_error "SSH timeout" 2
               }
            }
         }
         "Permission denied" {
            fail_with_error "Invalid credentials" 1
         }
         "Login failed" {
            fail_with_error "Invalid credentials" 1
         }
      }
   }
   "Connection refused" {
      fail_with_error "Connection refused" 3
   }
   timeout {
      fail_with_error "SSH timeout" 2
   }
}

# Check for pending firmware upgrade
log_msg "Checking for pending firmware upgrade"
send_cmd ":put \[/system/routerboard/print as-value\]"
after 3000
expect {
   -re $prompt {
      set parsed [parse_command_output $expect_out(buffer) ":put \[/system/routerboard/print as-value\]" {current-firmware=[^\r\n;]+;.*upgrade-firmware=[^\r\n;]+} $debug_mode]
      if {[dict size $parsed] > 0} {
         if {[dict exists $parsed current-firmware] && [dict exists $parsed upgrade-firmware]} {
            set current_firmware [dict get $parsed current-firmware]
            set upgrade_firmware [dict get $parsed upgrade-firmware]
            debug_log "Current firmware: '$current_firmware', Upgrade firmware: '$upgrade_firmware'"
            if {$current_firmware == $upgrade_firmware && $target_version != "" && $current_firmware == $target_version} {
               set early_exit 1
               log_msg "Firmware up-to-date: current-firmware=$current_firmware, upgrade-firmware=$upgrade_firmware"
            } elseif {$current_firmware != $upgrade_firmware} {
               log_msg "Firmware upgrade pending: current-firmware=$current_firmware, upgrade-firmware=$upgrade_firmware. Rebooting to apply."
               if {$test_mode} {
                  log_msg "Test mode: Skipping firmware reboot"
               } else {
                  send_cmd "/system/reboot"
                  expect {
                     -re {Reboot, yes\? \[y/N\]:[ \r\n]*} {
                        send_cmd "y"
                        expect {
                           eof {
                              log_msg "Firmware reboot command sent"
                           }
                           timeout {
                              fail_with_error "Timeout during firmware reboot command" 5
                           }
                        }
                     }
                     timeout {
                        fail_with_error "Timeout waiting for firmware reboot prompt" 5
                     }
                  }
                  log_msg "Waiting for $host_cli to reboot"
                  set attempt 0
                  while {$attempt < $max_attempts} {
                     after 10000
                     spawn ssh -o StrictHostKeyChecking=no $username$mtik_cli@$host
                     expect {
                        "password:" {
                           log_user 0
                           send "$password\r"
                           expect {
                              -re $prompt {
                                 log_msg "Reconnected to $host_cli after firmware reboot"
                                 break
                              }
                              timeout {
                                 log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
                              }
                           }
                        }
                        timeout {
                           log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
                        }
                     }
                     incr attempt
                     log_msg "Attempt $attempt of $max_attempts: Still waiting for $host"
                  }
                  if {$attempt >= $max_attempts} {
                     fail_with_error "Device $host_cli did not come back online after firmware reboot" 5
                  }
               }
            } else {
               log_msg "Firmware up-to-date: current-firmware=$current_firmware, upgrade-firmware=$upgrade_firmware"
            }
         } else {
            log_msg "No routerboard firmware information available, proceeding without firmware check"
         }
      } else {
         log_msg "No routerboard firmware output received, proceeding without firmware check"
      }
   }
   eof {
      fail_with_error "SSH session lost during routerboard query" 4
   }
   timeout {
      fail_with_error "Timeout waiting for routerboard response" 2
   }
}

# Backup configuration
set timestamp [clock format [clock seconds] -format "%Y%m%d_%H%M%S"]
set backup_file "$backup_dir/config.$host-$timestamp.rsc"
log_msg "Backing up configuration to $backup_file"
send_cmd ":put \[/export file=backup-$timestamp show-sensitive\]"
expect {
   -re $prompt {
      log_msg "Downloading backup file"
      set scp_cmd "SSHPASS='$password' sshpass -e scp -o StrictHostKeyChecking=no $username@$host:backup-$timestamp.rsc $backup_file"
      if {[catch {exec sh -c $scp_cmd} result]} {
         fail_with_error "SCP download failed: $result" 5
      }
      log_msg "Backup saved to $backup_file"
      if {![file readable $backup_file]} {
         fail_with_error "Backup file $backup_file is not readable" 5
      }
      set fp [open $backup_file r]
      set config_content [read $fp]
      close $fp
      if {$config_content == ""} {
         fail_with_error "Backup file $backup_file is empty" 5
      }
      set fp [open $backup_file w]
      puts $fp $config_content
      close $fp
      log_msg "Backup verified and saved"
      send_cmd "/file/remove backup-$timestamp.rsc"
      expect {
         -re $prompt {
            log_msg "Backup file backup-$timestamp.rsc deleted from $host"
            if {$early_exit} {
               log_msg "Current version $current_firmware matches target version $target_version, no upgrade needed"
               log_user 1
               if {$logging && [info exists log_file_handle]} {
                  debug_log "Closing log file handle: $log_file_handle"
                  catch {close $log_file_handle}
               }
               if {$debug_mode && [info exists debug_file_handle]} {
                  debug_log "Closing debug file handle: $debug_file_handle"
                  catch {close $debug_file_handle}
                  log_file
               }
               exit 0
            }
         }
         eof {
            fail_with_error "SSH session lost during backup file deletion" 4
         }
         timeout {
            log_msg "WARNING: Timeout waiting for backup file deletion response, proceeding"
         }
      }
   }
   eof {
      fail_with_error "Backup command failed" 5
   }
   timeout {
      fail_with_error "Backup command timeout" 5
   }
}

# Get system information
log_msg "Collecting system information"
send_cmd ":put \[/system/resource/print as-value\]"
after 1000
expect {
   -re $prompt {
      set parsed [parse_command_output $expect_out(buffer) ":put \[/system/resource/print as-value\]" {:put \[/system/resource/print as-value\].*?\r\n\r([^\r\n]+)\r\n} $debug_mode]
      if {[dict size $parsed] > 0} {
         if {[dict exists $parsed architecture-name] && [dict exists $parsed version]} {
            set arch [string trim [dict get $parsed architecture-name]]
            set raw_version [dict get $parsed version]
            if {[regexp {^([0-9.]+)} $raw_version {} current_version]} {
               debug_log "Parsed version: '$raw_version' -> '$current_version'"
            } else {
               set current_version $raw_version
            }
            log_msg "Architecture: $arch"
            log_msg "Current version: $current_version"
         } else {
            fail_with_error "Failed to parse architecture-name or version from system resource output" 5
         }
      } else {
         fail_with_error "No system resource output received" 5
      }
   }
   eof {
      fail_with_error "SSH session lost during system resource query" 4
   }
   timeout {
      fail_with_error "Timeout waiting for system resource response" 2
   }
}

# Check for addon packages
log_msg "Checking for addon packages"
send_cmd ":put \[/system/package/print as-value\]"
after 1000
expect {
   -re $prompt {
      set addon_packages [parse_packages $expect_out(buffer) ":put \[/system/package/print as-value\]" $debug_mode]
      if {[llength $addon_packages] > 0} {
         log_msg "Found addon packages: [join $addon_packages ", "]"
      } else {
         log_msg "No addon packages found"
      }
   }
   eof {
      fail_with_error "SSH session lost during package query" 4
   }
   timeout {
      fail_with_error "Timeout waiting for package response" 2
   }
}

# Find appropriate .npk files
log_msg "Searching for .npk files in $ros_image_dir for architecture $arch"
set npk_files {}
set npk_version ""
if {$target_version != ""} {
   set result [select_ros_version $target_version $arch $ros_image_dir $addon_packages]
   set npk_files [lindex $result 0]
   set npk_version [lindex $result 1]
} else {
   set found_files {}
   foreach file [glob -nocomplain $ros_image_dir/v*/routeros-*.npk] {
      debug_log "Checking file: $file"
      if {[regexp "routeros-(\[0-9.\]+)-${arch}\\.npk$" $file {} version]} {
         debug_log "Match found: $file (version $version)"
         lappend found_files [list $file $version]
         if {$npk_files == "" || [compare_versions $version $npk_version] > 0} {
            set npk_files [list $file]
            set npk_version $version
         }
      } else {
         debug_log "No match for architecture $arch: $file"
      }
   }
   if {$npk_files == ""} {
      fail_with_error "No ROS image matching architecture $arch found in $ros_image_dir, no upgrade possible" 5
   }
   # Check addon packages for default version
   set missing_packages {}
   foreach pkg $addon_packages {
      set pkg_file "$ros_image_dir/v$npk_version/$pkg-$npk_version-$arch.npk"
      debug_log "Checking for addon package file: $pkg_file"
      if {[file exists $pkg_file]} {
         lappend npk_files $pkg_file
         log_msg "Selected addon package: $pkg-$npk_version for $arch ($pkg_file)"
      } else {
         lappend missing_packages $pkg
         debug_log "Addon package $pkg-$npk_version-$arch.npk not found"
      }
   }
   if {[llength $missing_packages] > 0} {
      fail_with_error "Upgrade/downgrade unsuccessful due to missing version packages: [join $missing_packages ", "]" 5
   }
   log_msg "Selected .npk files: [join $npk_files ", "] (version $npk_version)"
}

# Check if current version matches or is newer than target version
set version_cmp [compare_versions $current_version $npk_version]
if {$version_cmp > 0} {
   log_msg "Current version $current_version is newer than target version $npk_version, checking for downgrade"
} elseif {$version_cmp == 0} {
   log_msg "Current version $current_version matches target version $npk_version, no upgrade needed"
   log_user 1
   exit 0
}

# Determine if downgrade is required
set downgrade_required [expr {$version_cmp > 0}]
if {$downgrade_required} {
   log_msg "Downgrade required to version $npk_version"
}

# Upload .npk files (or simulate in test mode)
if {$test_mode} {
   log_msg "Test mode: Skipping file uploads for [join $npk_files ", "]"
} else {
   foreach npk_file $npk_files {
      log_msg "Uploading $npk_file to $host"
      set scp_cmd "SSHPASS='$password' sshpass -e scp -o StrictHostKeyChecking=no $npk_file $username@$host:/[file tail $npk_file]"
      if {[catch {exec sh -c $scp_cmd} result]} {
         fail_with_error "SCP upload failed for $npk_file: $result" 5
      }
      log_msg "File upload completed for $npk_file"
   }
}

# Perform upgrade or downgrade
if {$downgrade_required} {
   if {$test_mode} {
      log_msg "Test mode: Skipping downgrade to $npk_version"
   } else {
      log_msg "Initiating downgrade"
      send_cmd "/system package downgrade"
      expect {
         -re {Router will be rebooted. Continue\? \[y/N\]:[ \r\n]*} {
            send_cmd "y"
            expect {
               eof {
                  log_msg "Downgrade reboot command sent"
                  set reboot_initiated 1
               }
               timeout {
                  fail_with_error "Timeout during downgrade reboot command" 5
               }
            }
         }
         timeout {
            fail_with_error "Timeout waiting for downgrade prompt" 5
         }
      }
   }
} else {
   if {$test_mode} {
      log_msg "Test mode: Skipping enabling auto-upgrade"
   } else {
      log_msg "Enabling auto-upgrade"
      send_cmd "/system/routerboard/settings/set auto-upgrade=yes"
      expect {
         -re $prompt {
            log_msg "Auto-upgrade enabled"
         }
         -re {.*expected end of command.*} {
            log_msg "WARNING: Auto-upgrade command failed, proceeding with manual reboot"
         }
         timeout {
            fail_with_error "Timeout waiting for auto-upgrade response" 5
         }
      }
      log_msg "Initiating reboot"
      send_cmd "/system/reboot"
      expect {
         -re {Reboot, yes\? \[y/N\]:[ \r\n]*} {
            send_cmd "y"
            expect {
               eof {
                  log_msg "Reboot command sent"
                  set reboot_initiated 1
               }
               timeout {
                  fail_with_error "Timeout during reboot command" 5
               }
            }
         }
         timeout {
            fail_with_error "Timeout waiting for reboot prompt" 5
         }
      }
   }
}

# Skip reboot if already initiated
if {$test_mode} {
   log_msg "Test mode: Skipping reboot"
   log_msg "Test mode: Simulating successful upgrade to version $npk_version"
   log_user 1
   exit 0
} elseif {$reboot_initiated} {
   log_msg "Reboot already initiated"
} else {
   fail_with_error "No reboot initiated, this should not happen" 5
}

# Wait for device to come back online
log_msg "Waiting for $host_cli to reboot"
set attempt 0
while {$attempt < $max_attempts} {
   after 10000
   spawn ssh -o StrictHostKeyChecking=no $username$mtik_cli@$host
   expect {
      "password:" {
         log_user 0
         send "$password\r"
         expect {
            -re $prompt {
               log_user 1
               log_msg "Reconnected to $host_cli after reboot"
               log_user 0
               break
            }
            timeout {
               log_user 1
               log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
               log_user 0
            }
         }
      }
      timeout {
         log_user 1
         log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
         log_user 0
      }
   }
   incr attempt
   log_msg "Attempt $attempt of $max_attempts: Still waiting for $host"
}

if {$attempt >= $max_attempts} {
   fail_with_error "Device $host_cli did not come back online" 5
}

# Verify new version
log_msg "Verifying new version"
send_cmd ":put \[/system/routerboard/print as-value\]"
after 1000
expect {
   -re $prompt {
      set parsed [parse_command_output $expect_out(buffer) ":put \[/system/routerboard/print as-value\]" {current-firmware=[^\r\n;]+;.*upgrade-firmware=[^\r\n;]+} $debug_mode]
      if {[dict size $parsed] > 0} {
         if {[dict exists $parsed current-firmware] && [dict exists $parsed upgrade-firmware]} {
            set current_firmware [dict get $parsed current-firmware]
            set upgrade_firmware [dict get $parsed upgrade-firmware]
            debug_log "Current firmware: '$current_firmware', Upgrade firmware: '$upgrade_firmware'"
            if {$current_firmware != $upgrade_firmware} {
               log_msg "Firmware upgrade pending: current-firmware=$current_firmware, upgrade-firmware=$upgrade_firmware. Rebooting to apply."
               if {$test_mode} {
                  log_msg "Test mode: Skipping firmware reboot"
               } else {
                  send_cmd "/system/reboot"
                  expect {
                     -re {Reboot, yes\? \[y/N\]:[ \r\n]*} {
                        send_cmd "y"
                        expect {
                           eof {
                              log_msg "Firmware reboot command sent"
                           }
                           timeout {
                              fail_with_error "Timeout during firmware reboot command" 5
                           }
                        }
                     }
                     timeout {
                        fail_with_error "Timeout waiting for firmware reboot prompt" 5
                     }
                  }
                  log_msg "Waiting for $host_cli to reboot"
                  set attempt 0
                  while {$attempt < $max_attempts} {
                     after 10000
                     spawn ssh -o StrictHostKeyChecking=no $username$mtik_cli@$host
                     expect {
                        "password:" {
                           log_user 0
                           send "$password\r"
                           expect {
                              -re $prompt {
                                 log_user 1
                                 log_msg "Reconnected to $host_cli after firmware reboot"
                                 log_user 0
                                 break
                              }
                              timeout {
                                 log_user 1
                                 log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
                                 log_user 0
                              }
                           }
                        }
                        timeout {
                           log_user 1
                           log_msg "Attempt [expr {$attempt + 1}] of $max_attempts: Still waiting for $host"
                           log_user 0
                        }
                     }
                     incr attempt
                     log_msg "Attempt $attempt of $max_attempts: Still waiting for $host"
                  }
                  if {$attempt >= $max_attempts} {
                     fail_with_error "Device $host_cli did not come back online after firmware reboot" 5
                  }
               }
            } else {
               log_msg "Firmware up-to-date: current-firmware=$current_firmware, upgrade-firmware=$upgrade_firmware"
            }
         } else {
            log_msg "No routerboard firmware information available, proceeding without firmware check"
         }
      } else {
         log_msg "No routerboard firmware output received, proceeding without firmware check"
      }
   }
   eof {
      fail_with_error "SSH session lost during routerboard query" 4
   }
   timeout {
      fail_with_error "Timeout waiting for routerboard response" 2
   }
}

# Final firmware check (for both upgrades and downgrades)
if {!$test_mode} {
   set firmware_verified [check_and_reboot_firmware $host_cli $username $password $prompt $max_attempts $test_mode $debug_mode $logging]
   if {!$firmware_verified} {
      fail_with_error "Final firmware verification failed" 5
   }
}

# Log success message
log_msg "Upgrade process completed successfully for $host"

# Clean up
if {$logging && [info exists log_file_handle]} {
   debug_log "Closing log file handle: $log_file_handle"
   catch {close $log_file_handle}
}
if {$debug_mode && [info exists debug_file_handle]} {
   debug_log "Closing debug file handle: $debug_file_handle"
   catch {close $debug_file_handle}
   log_file
}
log_user 0

exit 0